#include "TOTVS.ch"
#include "MsObject.ch"
#include "TLPP-Core.th"
#include "TLPP-Object.th"

using namespace Gworks.Library.Classes

namespace Gworks.Library.Classes

/*/{Protheus.doc} GwExecAuto
Classe para execução dinâmica de ExecAutos e com tratamento automático de erro.
@type class
@author Gwroks-Giovani
@since 4/3/2023
@since 4/3/2023
/*/
Class GwExecAuto

    Public data oError as object

    Public Data cExecAuto as character default ""

    Method New() Constructor
    Public Method RunExecAuto( nOpc as numeric, aData as array ) as logical

EndClass

/*/{Protheus.doc} GwExecAuto::New
Método construtor da classe.
@type method
@version 12.1.33
@author Gwroks-Giovani
@since 4/3/2023
@param cExecAuto, character, Nome do execauto desejado.
@return object, Retorna instância do object criado.
/*/
Method New( cExecAuto as character ) Class GwExecAuto

    Default cExecAuto := ""

    ::oError := GwError():New()
    ::oError:cFunName := "GwExecAuto"
    ::oError:cMethod := "New"
    if Empty(cExecAuto)
        ::oError:cError := "Parâmetro cExecAuto não informado ou inválido!"
        ::oError:ThrowException()
    endif

    ::oError := GwError():New()

    ::cExecAuto := cExecAuto

Return Self

/*/{Protheus.doc} GwExecAuto::RunExecAuto( nOperation as numeric, aKeyValue as array ) as logical
Método para executar ExecAutos de maneira dinâmica.
@type method
@version 12.1.33
@author Gwroks-Giovani
@since 4/3/2023
@return logical, Retorna .T. para sucesso e .F. para falhas na execução.
/*/
Method RunExecAuto( nOperation as numeric, aKeyValue as array ) as logical Class GwExecAuto

    Local aExecData     := {}   as array
    Local nI            := 0    as numeric
    Local nY            := 0    as numeric

    Local cField        := ""   as character
    Local xValue        := nil  as variant

    Local cParam        := ""   as character
    Local cBlock        := ""   as character
    Local bBlock        := {||} as block
    Local nLenParams    := 0    as numeric

    Local lResult       := .F.  as logical

    Private lMsErroAuto := .F.  as logical

    Default cExecAuto   := ""
    Default nOperation  := 0
    Default aKeyValue   := {}

    ::oError:cMethod := "RunExecAuto"

    if Empty(nOperation) .Or. Empty(aKeyValue)
        ::oError:cError := "Parâmetros não informados ou inválidos!"
        ::oError:ThrowException()
    endif

    for nI:=1 to Len(aKeyValue)
        oKeyValue := aKeyValue[nI]
        aAdd( aExecData, {} )
        for nY:=1 to oKeyValue:Length()
            cField := oResult:GetNameByPosition(nY)
            xValue := oResult:GetValueByPosition(nY)
            aAdd( aExecData[nI], { cField, xValue, nil } )
        next
    next

    if Empty(aExecData)
        ::oError:cError := "Sem dados a processar!"
        ::oError:ThrowException()
    endif

    cParam := "q"
    for nI:=1 to Len(aExecData)+1 // adiciona mais 1 devido à operação (inclusão, alteração, etc...)
        cParam += ', ' + soma1(cParam) // "q, r, s" etc...
    next

    cBlock := "{ | "+cParam+" | "+::cExecAuto+"( "+cParam+" ) }"
    bBlock := &(cBlock)
    nLenParams := Len(aExecData)

    do case

        case nLenParams == 1 ; MsExecAuto( bBlock, aExecData[01], nOperation )
        case nLenParams == 2 ; MsExecAuto( bBlock, aExecData[01], aExecData[02], nOperation )
        case nLenParams == 3 ; MsExecAuto( bBlock, aExecData[01], aExecData[02], aExecData[03], nOperation )
        case nLenParams == 4 ; MsExecAuto( bBlock, aExecData[01], aExecData[02], aExecData[03], aExecData[04], nOperation )
        case nLenParams == 5 ; MsExecAuto( bBlock, aExecData[01], aExecData[02], aExecData[03], aExecData[04], aExecData[05], nOperation )
        case nLenParams == 6 ; MsExecAuto( bBlock, aExecData[01], aExecData[02], aExecData[03], aExecData[04], aExecData[05], aExecData[06], nOperation )
        case nLenParams == 7 ; MsExecAuto( bBlock, aExecData[01], aExecData[02], aExecData[03], aExecData[04], aExecData[05], aExecData[06], aExecData[07], nOperation )
        case nLenParams == 8 ; MsExecAuto( bBlock, aExecData[01], aExecData[02], aExecData[03], aExecData[04], aExecData[05], aExecData[06], aExecData[07], aExecData[08], nOperation )
        case nLenParams == 9 ; MsExecAuto( bBlock, aExecData[01], aExecData[02], aExecData[03], aExecData[04], aExecData[05], aExecData[06], aExecData[07], aExecData[08], aExecData[09], nOperation )
        case nLenParams == 9 ; MsExecAuto( bBlock, aExecData[01], aExecData[02], aExecData[03], aExecData[04], aExecData[05], aExecData[06], aExecData[07], aExecData[08], aExecData[09], aExecData[10], nOperation )
        otherwise
            ::oError:cError := "Quantidade de parâmetros no execauto não suportada!"
            ::oError:ThrowException()
    endcase

    // Exemplo:
    // MsExecAuto( { | q, r, s | Mata105( q, r, s ) }, aCabec, aItens, nOpc )

    if lMsErroAuto

        RollBackSx8()

        DisarmTransaction()

        ::oError:DefineWithError(.T.)

        ::oError:SetAutoGRLogFromExecAuto(::cExecAuto)

    else

        ::oError:DefineWithError(.F.)

        ConfirmSX8()

        lResult := .T.

    endif

Return lResult
